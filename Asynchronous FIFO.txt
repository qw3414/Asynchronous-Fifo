module gray_to_bin(input [3:0] gray,
                   output reg [3:0] binary);
   
  always@(*) begin
      begin
        binary[0] = gray[3] ^ gray[2] ^ gray[1]^ gray[0];
        binary[1] = gray[3] ^ gray[2] ^ gray[1];
        binary[2] = gray[3] ^ gray[2];
        binary[3] = gray[3];
      end
  end
endmodule
 
module bin_to_gray(input [3:0] binary, output reg [3:0] gray);
       
        always@(*)
          begin
            gray[3] = binary[3];
            gray[2] = binary[3]^binary[2];
            gray[1] = binary[2]^binary[1];
            gray[0] = binary[1]^binary[0];
          end
      
        endmodule

module memory(input [2:0] wr_ptr,
              input [2:0] rd_ptr,
              input [31:0] data_in,
              input wr_en,
              input rd_en,
              output reg [31:0] rd_data);
  reg [31:0]  mem [0:7]; //8 bit depth and 32 bit wide data
  always @(*) begin
    if (wr_en) begin
      mem[wr_ptr] = data_in;
    end

    if (rd_en) begin
      rd_data = mem[rd_ptr];
    end else begin
      rd_data = 32'd0;
  end
  end
endmodule
 
module write_pointer( input wr_clk,
                     input [3:0] rd_ptr_w, //rd_ptr in wr clk domain
                     input wr_en,
                     output reg [3:0] wr_ptr,
                     output full);
  assign full = ({!wr_ptr[3],wr_ptr[2:0]} == rd_ptr_w[3:0]);
  always@(posedge wr_clk) begin
    if(wr_en && !full) 
      wr_ptr <= wr_ptr+1;
    else 
      wr_ptr <= wr_ptr;
  end 
endmodule
                     
module read_pointer( input[3:0]wr_ptr_r,//wr_ptr in rd clk domain
                    input rd_clk,
                    input rd_en,
                    output reg [3:0] rd_ptr,
                    output empty);
  assign empty = (wr_ptr_r == rd_ptr );
  always@(posedge rd_clk) begin
    if (rd_en && !empty) 
      rd_ptr <= rd_ptr + 1'b1;
    else rd_ptr <= rd_ptr;
  end
endmodule

module async_fifo(input rd_clk,
                  input wr_clk,
                  input [31:0] data_wr,
                  input wr_en,
                  input rd_en_receiver,
                  input wr_en_sender,
                  output [31:0] rd_data,
                  output f,e);//to monitor full and empty conditions
  wire [3:0] wr_ptr, rd_ptr, wr_ptr_gray_rd_clk, wr_ptr_rd_clk, rd_ptr_gray_wr_clk, rd_ptr_wr_clk, rd_ptr_gray, wr_ptr_gray;
  wire wr_en_mem, rd_en_mem;
  reg [3:0] a,b,c,d;
  assign wr_en_mem = wr_en_sender & !f;
  assign rd_en_mem = rd_en_receiver & !e;
  
  memory fifo (.rd_ptr(rd_ptr[2:0]), .wr_ptr(wr_ptr[2:0]), .data_in(data_wr), .wr_en(wr_en_mem), .rd_en(rd_en_mem), .rd_data(rd_data));
  
  read_pointer r (.wr_ptr_r(wr_ptr_rd_clk), .rd_clk(rd_clk), .rd_en(rd_en_receiver), .rd_ptr(rd_ptr), .empty(e));

  write_pointer w (.wr_clk(wr_clk), .rd_ptr_w(rd_ptr_wr_clk), .wr_en(wr_en), .wr_ptr(wr_ptr), .full(f));
  
  gray_to_bin right (.gray(wr_ptr_gray_rd_clk), .binary(wr_ptr_rd_clk));
  gray_to_bin left (.gray(rd_ptr_gray_wr_clk), .binary(rd_ptr_wr_clk));
  
  bin_to_gray right_ (.binary(rd_ptr), .gray(rd_ptr_gray));
  bin_to_gray left_ (.binary(wr_ptr), .gray(wr_ptr_gray));

  always@(posedge rd_clk) begin
    a <= wr_ptr_gray;
    b <= a;
  end
  assign wr_ptr_gray_rd_clk = b;
  
  always@(posedge wr_clk) begin
    c <= rd_ptr_gray;
    d <= c;
  end
  assign rd_ptr_gray_wr_clk = d;
endmodule