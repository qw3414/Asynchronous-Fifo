module gray_to_bin(input [3:0] gray,
                   output [3:0] binary)
  begin 
    always@(*)
      begin
        binary[0] = gray[3] ^ gray[2] ^ gray[1]^ gray[0];
        binary[1] = gray[3] ^ gray[2] ^ gray[1];
        binary[2] = gray[3] ^ gray[2];
        binary[3] = gray[3];
      end
  end
    endmodule
 
module bin_to_gray(input [3:0] binary, output [3:0] gray)
      begin 
        always@(*)
          begin
            gray[3] = binary[3];
            gray[2] = binary[3]^binary[2];
            gray[1] = binary[2]^binary[1];
            gray[0] = binary[1]^binary[0];
          end
      end
        endmodule

module memory( input [2:0] wr_ptr,
              input [2:0] rd_ptr,
              input [31:0] data_in,
              input wr_en,
              input rd_en,
              output [31:0] rd_data)
  reg [31:0]  mem [0:7]; //8 bit depth and 32 bit wide data
  always@(*) begin 
    if(wr_en) begin mem[wr_ptr] = data_in; end
    else if (rd_en) begin mem[rd_ptr] = rd_data; end
  end
endmodule
 
module write_pointer( input wr_clk,
                     input [3:0] rd_ptr_w, //rd_ptr in wr clk domain
                     input wr_en,
                     output [3:0] wr_ptr,
                     output full)
  reg wr_ptr[3:0];
  always@(*) begin 
    if({!wr_ptr[3]},wr_ptr[2:0]} == rd_ptr[3:0]) 
      full = 1'b1;
  end
  
  always@(posedge wr_clk) begin
    if(wr_en && !full) 
      wr_ptr <= wr_ptr+1;
    else 
      wr_ptr <= wr_ptr;
  end 
endmodule
                     
module read_pointer( input[3:0]wr_ptr_r,//wr_ptr in rd clk domain
                    input rd_clk,
                    input rd_en,
                    output [3:0] rd_ptr,
                    output empty)
  reg rd_ptr[3:0];
  if (wr_ptr_r[3:0] = rd_ptr [3:0])
assign empty = 1'b1;
  always@(posedge rd_clk) begin
    if (rd_en && !empty) 
      rd_ptr <= rd_ptr + 1'b1;
    else rd_ptr <= rd_ptr;
  end
endmodule

module async_fifo(input rd_clk,
                  input wr_clk,
                  input data_wr,
                  input wr_en,
                  input rd_en_receiver,
                  input wr_en_sender,
                  output rd_data,
                  output f,e)//to monitor full and empty conditions
  wire [31:0] rd_data;
  wire [3:0] wr_ptr, rd_ptr, wr_ptr_gray_rd_clk, wr_ptr_rd_clk, rd_ptr_gray_wr_clk, rd_tr_wr_clk;
  wire wr_en_mem, rd_en_mem;
  wire [3:0] a,b,c,d;
  assign wr_en_mem = wr_en & !full;
  assign rd_en_mem = rd_en & !empty;
  
 memory fifo (.rd_ptr(rd_ptr), .rd_ptr(rd_ptr), .data_in(data_wr), .wr_en(wr_en_mem), .rd_en(rd_en_mem), .rd_data(rd_data));
  
  read_pointer r (.wr_ptr_r(wr_ptr_rd_clk), .rd_clk(rd_clk), .rd_en(rd_en), .rd_ptr(rd_ptr), .empty(e));

  write_pointer w (.wr_clk(wr_clk), .rd_ptr_w(rd_ptr_wr_clk), .wr_en(wr_en), .wr_ptr(wr_ptr), .full(f));
  
  gray_to_bin right (.gray(wr_ptr_gray_rd_clk), .binary(wr_ptr_rd_clk));
  gray_to_bin left (.gray(rd_ptr_gray_wr_clk), .binary(rd_ptr_wr_clk));
  
  bin_to_gray right (.binary(rd_ptr), .gray(rd_ptr_gray));
  bin_to_gray left (.binary(wr_ptr), .gray(wr_ptr_gray));

  always@(posedge rd_clk) begin
    a <= wr_ptr_gray;
    b <= a;
  end
  assign wr_ptr_gray_rd_clk = b;
  
  always@(posedge wr_clk) begin
    c <= rd_ptr_gray;
    d <= c;
  end
  assign rd_ptr_gray_wr_clk = d;
endmodule